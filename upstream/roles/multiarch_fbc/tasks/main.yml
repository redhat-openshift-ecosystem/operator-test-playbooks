---
- name: "Set multiarch base"
  set_fact:
    multiarch_base: "{{ mirror_multiarch_image }}"

- name: "Set multiarch base"
  set_fact:
    mfbc_list_architectures_from: "{{ multiarch_base }}"

- name: "Tweak Dockerfile to accept arch args part 1"
  lineinfile:
    path: "{{ mfbc_dockerfile_path }}"
    insertbefore: BOF
    line: 'ARG ARCH='

- name: "Tweak Dockerfile to accept arch args part 2"
  replace:
    path: "{{ mfbc_dockerfile_path }}"
    regexp: "FROM quay.io/operator-framework/opm:latest"
    replace: "FROM {{ multiarch_base }}-${ARCH}"

- name: "Show Dockerfile"
  shell: "cat {{ mfbc_dockerfile_path }}"

- name: "Fail on registry.redhat.io login "
  fail:
    msg: "Unable to login to registry.redhat.io with user '{{ registry_redhat_io_user }}'"
  when: 
    - mfbc_list_architectures_from.startswith('registry.redhat.io')
    - (registry_redhat_io_user is undefined and registry_redhat_io_token is undefined) or (registry_redhat_io_user|length == 0 or registry_redhat_io_token|length == 0)

- name: "Login to registry.redhat.io"
  shell: "{{ container_tool }} login -u={{ registry_redhat_io_user }} -p='{{ registry_redhat_io_token }}' registry.redhat.io"
  # no_log: true
  when: 
    - registry_redhat_io_user is defined and registry_redhat_io_token is defined 
    - registry_redhat_io_user|length > 0 or registry_redhat_io_token|length > 0
    - mfbc_list_architectures_from.startswith('registry.redhat.io')

- name: "Detect needed architectures from image '{{ mfbc_list_architectures_from }}'"
  shell: "{{ container_tool }} manifest inspect {{ mfbc_list_architectures_from }} | {{ jq_bin_path }} '.manifests[].platform.architecture' -r"
  register: mfbc_archs_inspect_result

- name: "Parse archs to list"
  set_fact:
    multiarch_fbc_architectures: "{{ mfbc_archs_inspect_result.stdout_lines | list }}"

- name: "Print archs list'"
  debug:
    var: multiarch_fbc_architectures

- name: "Print mfbc_multi_arch_output_image"
  debug:
    var: mfbc_multi_arch_output_image

- name: "Remove manifest '{{ mfbc_multi_arch_output_image }}' before creating a new one"
  shell: "{{ container_tool }} rmi -f {{ mfbc_multi_arch_output_image }}"
  failed_when: false

- name: "Create the final manifest"
  shell: "{{ container_tool }} manifest create {{ mfbc_multi_arch_output_image }}"
  args:
    chdir: "{{ mfbc_extracted_fbc_location }}"

- name: "Create and push archs one by one"
  include_tasks: process_archs.yml
  loop: "{{ multiarch_fbc_architectures }}"
  loop_control:
    loop_var: mfbc_architecture

- name: "Push final manifest '{{ mfbc_multi_arch_output_image }}'"
  shell: "{{ container_tool }} manifest push {{ mfbc_multi_arch_output_image }}"
  args:
    chdir: "{{ mfbc_extracted_fbc_location }}"
  register: mfbc_rc
  when:
    - container_tool is defined
    - container_tool == 'docker'

- name: "Push final manifest '{{ mfbc_multi_arch_output_image }}'"
  shell: "{{ container_tool }} manifest push {{ mfbc_multi_arch_output_image }} {{ image_protocol }}{{ mfbc_multi_arch_output_image }}"
  args:
    chdir: "{{ mfbc_extracted_fbc_location }}"
  register: mfbc_rc
  when:
    - container_tool is defined
    - container_tool == 'podman'
